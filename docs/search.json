[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LLM Agentic Systems",
    "section": "",
    "text": "Preface\nIn March of 2025, I had the new exciting opportunity to join a new team developing foundational models and AI agents. Since the field of agents is new and rapidly evolving, the number of established texts or formal courses on AI agents is sparse. A common joke in this field is that by the time someone writes a book, half of the content becomes outdated when finished. Instead, most people that I know stay up to date by continually reading blogs, tweets, and papers. However, without a comprehensive text, it can be hard to see how concepts fit together within the bigger picture. This is true especially when definitions are still being debated, new perspectives are still being developed, and new terms are being invented. A recent example is the term “context engineering”, which gained popularity after a discussion on X on June of 2025, where the term was introduced to unify the goals of prompt engineering, memory management, tool use, etc.\nI started this online book as an attempt to organize and aggregate the lessons I learned along the way as I build agents. I use the structure of a book to organize ideas and concepts coherently, and choose the format to be online to easily incorporate updates in the field, which are frequent. The contents are drawn from my learnings from research papers, blogs, talks, and the practical experience of building agents. My goal is to write in sufficient levels of depth and detail to reveal how things work “underneath the hood”, which may be difficult to see when most frameworks and agent-building tools abstract away those details. However, knowing these details is more empowering as it allows us to build more freely, concretely, and effectively, instead of attributing certain agentic abilties to “magic”. Hence, this book will have a focus on describing low-level agent mechanisms with code illustrations when appropriate. Given how new and evolving the field of AI agents are, the definitions and perspectives of this book may not necessarily align with everyone’s views or stand the test of time, nor are they meant to be comprehensive. Rather, the aim is to provide one valid mental model of how agents work to help people get started with building agents.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Prompt\nIn artifical intelligence (AI), an agent is broadly defined as anything that can perceive and act in its own environment (Norvig and Intelligence 2002). With the rise of large language models (LLMs), LLMs are now used to power modern agentic systems by leveraging their much more powerful and generalized intelligence capabilities that emerged from scale (Brown et al. 2020; Wei et al. 2022). At its best, a LLM can dynamically decide the sequence of steps that need to be executed in order to accomplish a given task, essentially achieving autonomy.\nIn practice, agentic systems differ in the degree of reliance on the LLM as a decision maker, since the increased flexibility that LLMs provide comes with the cost of reliability. On one end of this spectrum is a LLM workflow, which has LLMs participate in a limited scope within a broader predefined workflow. The steps are pre-defined and the LLM is tasked with making some of the decisions. On the other end of the spectrum is a LLM agent, where the LLM directs its own workflow to accomplish a task - deciding what and how many steps to take. We can illustrate the difference between a workflow and an agent with a customer service chatbot example:\nWhile an agent can tackle tasks more adaptively, it also becomes less predictable and reliable. On the other hand, workflows are more deterministic and reliable, but are limited in their ability to tackle more open-ended tasks where there may not be one obvious approach. Choosing between a workflow and an agent requires considering the balance of flexibility and reliability needed for the application. In the rest of this book, the word agent will be used interchangeably with agentic systems, with the distinction between workflows and agents expliclty stated when necessary.\nBuilding an agentic system from a LLM requires a prompt, tools, and memory. The prompt is piece of text that instructs the LLM on how to behave within the agent application. Tools allow an agent to take actions and is typically accessed by an agentic system in the form of an API. Finally, memory allows an agent to act and behave in a contextualized manner, with user information or conversation history being common memory contexts. Each of these components are the building blocks that can be used to create and shape a LLM agent. Figure 1.1 illustrates an agentic system and its components:\nA prompt is a piece of text that instructs a LLM how to behave within an agent application. A prompt can be organized conceptually into a system prompt, contextual prompt, role prompt, and a user prompt. In the end, they are all concatenated together into a single text input when invoking the LLM (i.e. asking LLM to generate response).\nCome LLM inference time, the process of putting together the final prompt typically involves concatenating the system prompt, one of the role prompts, the contextual prompt with contextual values filled in, and the user input. Below is an example for a bank agent chatbot, using AWS bedrock to access a LLM\nimport boto3\n\nSYSTEM_PROMMPT = \"\"\"\n&lt;instruction&gt;\nYou are a helpful agent for XYZ bank. You are ALWAYS patient, helpful, and always try to \nassist the user in the best way possible. \n&lt;/instruction&gt;\n\"\"\"\n\nROLE_PROMPT_REPORTING = \"\"\"\nYou are tasked with account reporting. \nUse the following function to look up the account information:\n\n{\n    \"function_name\": \"account_lookup\",\n    \"description\": \"a tool to retrieve account information for a user.\",\n    \"arguments\": {\n        \"username\": {\"type\": str, \"description\": \"user name\"},\n        \"security_code\": {\"type\": str, \"description\": \"security code\"}\n    }\n}\n\nNEVER reveal account Ids.\n\"\"\"\n\nCONTEXTUAL_PROMPT = \"\"\"\nUse below account information &lt;account&gt; about the customer:\n\n&lt;account&gt;\nUsername: {username}\naccount_type: {account_type}\n&lt;/account&gt;\n\"\"\"\n\nuser_input = \"Can you get the ending balance of each month for 2024?\"\nbedrock_runtime = boto3.client(\"bedrock-runtime\", region_name=\"us-west-1\")\nbedrock_runtime_response = bedrock_runtime.converse(\n    modelId = \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n    system = [\n                {'text': SYSTEM_PROMMPT}, \n                {'text': ROLE_PROMPT_REPORTING}, \n                {'text': CONTEXTUAL_PROMPT.format(username = \"caleb\", \n                                                  account_type = \"savigns\")}\n    ],\n    messages = [{\"role\": \"user\", \"content\": [{\"text\": user_input}]}]\n)\nAccording to Anthropic, using XML tags in your prompts can help Claude models parse specific components in your prompt more easily. For example, better identifying which part of the prompt is the system prompt by the &lt;instruction&gt; tag. As a heuristic, capitalize words for emphasis, such as the words “NEVER” or “ALWAYS”.",
    "crumbs": [
      "Concepts",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#prompt",
    "href": "introduction.html#prompt",
    "title": "1  Introduction",
    "section": "",
    "text": "System prompt: contains high level instructions that should always be applied and thus is always part of the input text when invoking a LLM. Typically, the system prompt contains instructions asking the LLM to be a helpful and patient agent.\nRole prompt: in an agentic system, LLMs may be required to behave differently depending on the scenario. For example, in multi-agent collaboration where multiple specialized agents communicate together to solve as task, each specialized agent will need a role prompt. To implement this behavior, multiple role prompts are maintained and a specific role prompt is selected and concatenated with the remaining prompts depending on the scenario or role.\nUser prompt: the question or instruction from the user of the agent application. The user prompt is typically appended to the end of the final prompt that is passed to the LLM.\nContextual prompt: catch-all prompt for all contextual details needed for an agent to respond to a user request. For industry applications, this could be the account information of the user in the current conversation session. Having a contextual prompt is important for a good and safe user experience as it saves the user from having to state user information that might be later used by the agent.",
    "crumbs": [
      "Concepts",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#tools",
    "href": "introduction.html#tools",
    "title": "1  Introduction",
    "section": "1.2 Tools",
    "text": "1.2 Tools\nThe tools of an agent are the software services that a LLM can access via API calls, which gives the LLM a means to interact with the outside environment, and imbues an agent with specialized abilities. Common LLM tools include database access (for retrieval augmented generation (RAG)), web search, code interpreter, and calculator. For real-world agent applications, these tools can be specialized in-house services such as a recommendation system or placing an order.\nConcretely, a LLM “accesses” tools by generating an API call string, typically in the standardized JSON format for ease of parsing. Then, the API call string is passed to the client side, which extracts key entities like the tool name and arguments, followed by making the API call to the specified tool with the extracted arguments. While this is in principle possible with regular language models in the pre-LLM era, tool-use became more main stream as LLMs developed the instruction-following ability to generate API calls reliably if you simply provide the tool use instructions and tool documentation (e.g. tool name and required arguments) in the input prompt.\nTo illustrate the mechanism of tool-use, suppose we add to the LLM prompt the following documentation on a weather function so that the LLM knows how to generate the API call string when the user asks for the weather on a given day:\n{\n  \"name\": \"get_temperature_by_day\",\n  \"description\": \"Returns the forecasted temperature in Celsius for a specified day of the week.\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"day\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the day of the week (e.g., 'Monday', 'Tuesday'). Case-insensitive.\"\n      }\n    },\n    \"required\": [\"day\"]\n}\nAdditionally suppose in the prompt we instruct the model to generate the API call in JSON format for ease of parsing, for example:\n{\n    \"name\": \"get_temperature_by_day\",\n    \"arguments\": {\n        \"day\": \"Tuesday\"\n    }\n}\nThen, the code to parse and execute the function could look like:\n\nimport json\n\ndef get_temperature_by_day(day):\n    if day == \"Tuesday\":\n        return 27\n    return 30\n\ntool_call_string = \"\"\"\n{\n    \"name\": \"get_temperature_by_day\",\n    \"arguments\": {\n        \"day\": \"Tuesday\"\n    }\n}\n\"\"\"\n\n# Parsing LLM tool call string to extract tool name and argument\ntool_call_json = json.loads(tool_call_string)\nday = tool_call_json[\"arguments\"][\"day\"]\nfunc_name = tool_call_json[\"name\"]\n\n# Tool execution\ntemperature = globals()[func_name](day)\nprint(\"Temperature for {day} is {temp}C\".format(day = day, temp = temperature))\n\nTemperature for Tuesday is 27C\n\n\nFigure Figure 1.2 shows the life cycle of a function call, and shows that the role of a LLM in tool calling is to map the user question to the corresponding tool call JSON output.\n\n\n\n\n\n\nFigure 1.2: In this example life cycle of a function call, the agent processes the user request and decides to use the Google Places API. First, example API calls are added to the prompt for in-context learning, then the LLM generates the tool call JSON payload, which gets sent to the client side to process and make the API call. The API call results are then fed to the LLM for final response generation. Source: “Agents” (https://www.kaggle.com/whitepaper-agents).",
    "crumbs": [
      "Concepts",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#memory",
    "href": "introduction.html#memory",
    "title": "1  Introduction",
    "section": "1.3 Memory",
    "text": "1.3 Memory\nFinally, memory allows an agent to accumulate conversation history as context, allowing responses to become highly contextualized and efficient. Perhaps inspired by the biological mind, people like to categorize agent memory into short-term or long-term memory, with implications for usage and implementation.\nShort-term memory typically describes the conversation history of the current conversation session, which might revolve around solving a single task or topic. Like the RAM for computers, it acts as the working memory of the agent, which is typically stored in a buffer or list without further processing and passed to the LLM for each response.\nLong-term memory refers to the collection of conversation history across sessions. Since each session may concern a different topic, long-term memory is typically only accessed by an agent when relevant to the current conversation, and is thus stored in external databases that can be retrieved (e.g. vector data store for semantic retrieval). When long-term memory is retrieved for the current conversation session, it may get summarized first before passing to the LLM in order to utilize its context window efficiently. An example of this long-term memory processing is in the multi-agent collaboration of ChatDev, where each long-term memory is the conversation history between two agents for solving a subtask (Qian et al. 2023). To start the next subtask, the solution to the previous subtask is extracted from long-term memory and loaded into the LLM context.",
    "crumbs": [
      "Concepts",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "context.html",
    "href": "context.html",
    "title": "2  Context Engineering",
    "section": "",
    "text": "LLMs are trending towards having longer context windows, capable of processing upwards of millions of tokens. This is regarded as beneficial overall, as larger contexts allow a model to process more information and solve more complex problems. However, research from Chroma showed that model performance degrades as context length increases, a phenomenom their research team coined “context rot” (Hong, Troynikov, and Huber 2025).\n\nhttps://research.trychroma.com/context-rot\nhttps://www.philschmid.de/context-engineering\nhttps://blog.langchain.com/context-engineering-for-agents/\n\n\nReferences\n\n\n\n\nHong, Kelly, Anton Troynikov, and Jeff Huber. 2025. “Context Rot: How Increasing Input Tokens Impacts LLM Performance.” Chroma. https://research.trychroma.com/context-rot.",
    "crumbs": [
      "Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Context Engineering</span>"
    ]
  }
]